name: "Serv00/CT8 SSH Login & Run start.sh (Auto Proxy Logic)"

on:
  workflow_dispatch:
    inputs:
      custom_command:
        description: '要执行的自定义命令'
        required: false
  schedule:
    - cron: "23 8 * * *"  # 每天北京时间16:23执行 (伪随机)

env:
  ACCOUNTS_JSON: ${{ secrets.ACCOUNTS_JSON }}
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
  SOCKS5_PROXY: ${{ secrets.SOCKS5_PROXY }}
  CUSTOM_COMMAND: ${{ github.event.inputs.custom_command || vars.CUSTOM_COMMAND || secrets.CUSTOM_COMMAND }}

defaults:
  run:
    shell: bash

jobs:
  ssh-run-start:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y sshpass jq curl netcat-openbsd proxychains4

      - name: Check SOCKS5 proxy if set
        id: proxy_check
        if: env.SOCKS5_PROXY != ''
        run: |
          echo "proxy_available=false" >> $GITHUB_OUTPUT
          AVAILABLE_PROXY=""
          PROXY_REPORT=""
          
          while read -r proxy; do
            [ -z "$proxy" ] && continue
          
            PROTO=$(echo "$proxy" | cut -d: -f1)
            USERPASS=$(echo "$proxy" | cut -d/ -f3 | cut -d@ -f1)
            if [[ "$USERPASS" == *:* ]]; then
              USER=$(echo "$USERPASS" | cut -d: -f1)
              PASS=$(echo "$USERPASS" | cut -d: -f2)
            else
              USER=""
              PASS=""
            fi
            HOST=$(echo "$proxy" | cut -d@ -f2 | cut -d: -f1)
            PORT=$(echo "$proxy" | rev | cut -d: -f1 | rev)
          
            if nc -z -w3 "$HOST" "$PORT"; then
              PROXY_REPORT="${PROXY_REPORT}✅ $proxy (可用)\n"
          
              if [ -n "$USER" ] && [ -n "$PASS" ]; then
                sudo bash -c "printf 'strict_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n[ProxyList]\n%s %s %s %s %s\n' \
                  '$PROTO' '$HOST' '$PORT' '$USER' '$PASS' > /etc/proxychains4.conf"
              else
                sudo bash -c "printf 'strict_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n[ProxyList]\n%s %s %s\n' \
                  '$PROTO' '$HOST' '$PORT' > /etc/proxychains4.conf"
              fi
          
              AVAILABLE_PROXY="$proxy"
              break
            else
              PROXY_REPORT="${PROXY_REPORT}❌ $proxy (不可用)\n"
            fi
          done <<< "$SOCKS5_PROXY"
          
          if [ -z "$AVAILABLE_PROXY" ]; then
            FAIL_MSG="❌ 没有可用的 SOCKS5 代理\n${PROXY_REPORT}任务终止 at $(date '+%Y-%m-%d %H:%M:%S')"
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d chat_id="${TELEGRAM_CHAT_ID}" \
              --data-urlencode text="$(echo -e "$FAIL_MSG")"
          else
            echo "本次使用代理: $AVAILABLE_PROXY"
            echo "$AVAILABLE_PROXY" > selected_proxy.txt
            echo -e "$PROXY_REPORT" > proxy_report.txt
            echo "==== proxychains4.conf ===="
            cat /etc/proxychains4.conf
            echo "proxy_available=true" >> $GITHUB_OUTPUT
          fi

      - name: Create accounts.json
        run: echo "$ACCOUNTS_JSON" > accounts.json

      - name: Generate and execute SSH commands (via proxy)
        if: env.SOCKS5_PROXY != '' && steps.proxy_check.outputs.proxy_available == 'true'
        run: |
          OUTPUT_FILE="ssh_output.txt"
          : > "$OUTPUT_FILE"
          while IFS= read -r account; do
            username=$(echo "$account" | jq -r '.username')
            password=$(echo "$account" | jq -r '.password')
            ssh_addr=$(echo "$account" | jq -r '.panel')
            echo "===== $username@$ssh_addr =====" | tee -a "$OUTPUT_FILE"
            proxychains4 sshpass -p "$password" ssh -o StrictHostKeyChecking=no "$username@$ssh_addr" "$CUSTOM_COMMAND" 2>&1 | tee -a "$OUTPUT_FILE"
            echo "" >> "$OUTPUT_FILE"
          done < <(jq -c '.[]' accounts.json)

      - name: Generate and execute SSH commands (direct)
        if: env.SOCKS5_PROXY == ''
        run: |
          OUTPUT_FILE="ssh_output.txt"
          : > "$OUTPUT_FILE"
          while IFS= read -r account; do
            username=$(echo "$account" | jq -r '.username')
            password=$(echo "$account" | jq -r '.password')
            ssh_addr=$(echo "$account" | jq -r '.panel')
            echo "===== $username@$ssh_addr =====" | tee -a "$OUTPUT_FILE"
            sshpass -p "$password" ssh -o StrictHostKeyChecking=no "$username@$ssh_addr" "$CUSTOM_COMMAND" 2>&1 | tee -a "$OUTPUT_FILE"
            echo "" >> "$OUTPUT_FILE"
          done < <(jq -c '.[]' accounts.json)

      - name: Send Telegram notification with output
        if: always() && (env.SOCKS5_PROXY == '' || (env.SOCKS5_PROXY != '' && steps.proxy_check.outputs.proxy_available == 'true'))
        run: |
          STATUS="✅ 执行完成"
          if [ "${{ job.status }}" != "success" ]; then
            STATUS="❌ 执行失败"
          fi
          if [ -f proxy_report.txt ]; then
            PROXY_INFO="$(cat proxy_report.txt)"
          else
            PROXY_INFO="无代理 (直接连接)"
          fi
          MSG="$(cat ssh_output.txt 2>/dev/null || echo '无 SSH 输出')"
          MSG_TRUNC="${MSG:0:3500}"
          FULL_MSG="$STATUS\n本次代理检测:\n$PROXY_INFO\n执行时间: $(date '+%Y-%m-%d %H:%M:%S')\n\`\`\`\n$MSG_TRUNC\n\`\`\`"
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d chat_id="${TELEGRAM_CHAT_ID}" \
            -d parse_mode="Markdown" \
            --data-urlencode text="$(echo -e "$FULL_MSG")"
