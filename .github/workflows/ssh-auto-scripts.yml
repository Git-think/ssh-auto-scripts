name: "SSH Login & Run COMMAND (SOCKS5 Check + TG Direct + Proxy Info)"

on:
  workflow_dispatch:
    inputs:
      custom_command:
        description: '要执行的自定义命令'
        required: false
  schedule:
    - cron: "23 8 * * *"  # 每天北京时间16:23执行 (伪随机)

env:
  ACCOUNTS_JSON: ${{ secrets.ACCOUNTS_JSON }}
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
  SOCKS5_PROXY: ${{ secrets.SOCKS5_PROXY }}
  CUSTOM_COMMAND: ${{ github.event.inputs.custom_command || vars.CUSTOM_COMMAND || secrets.CUSTOM_COMMAND }}

defaults:
  run:
    shell: bash

jobs:
  ssh-run-start:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up SSHPass and ProxyChains
        run: |
          sudo apt-get update && sudo apt-get install -y sshpass jq curl netcat-openbsd proxychains4
          AVAILABLE_PROXY=""
          PROXY_REPORT=""
          
          while read -r proxy; do
            [ -z "$proxy" ] && continue
          
            # ==== 解析协议 ====
            PROTO=$(echo "$proxy" | cut -d: -f1)
          
            # ==== 解析用户名密码 ====
            USERPASS=$(echo "$proxy" | cut -d/ -f3 | cut -d@ -f1)
            if [[ "$USERPASS" == *:* ]]; then
              USER=$(echo "$USERPASS" | cut -d: -f1)
              PASS=$(echo "$USERPASS" | cut -d: -f2)
            else
              USER=""
              PASS=""
            fi
          
            # ==== 解析主机与端口 ====
            HOST=$(echo "$proxy" | cut -d@ -f2 | cut -d: -f1)
            PORT=$(echo "$proxy" | rev | cut -d: -f1 | rev)
          
            # ==== 测试代理是否可用 ====
            if nc -z -w3 "$HOST" "$PORT"; then
              PROXY_REPORT="${PROXY_REPORT}✅ $proxy (可用)\n"
          
              # ==== 写入 proxychains4.conf ====
              if [ -n "$USER" ] && [ -n "$PASS" ]; then
                # 带账号密码
                sudo bash -c "printf 'strict_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n[ProxyList]\n%s %s %s %s %s\n' \
                  '$PROTO' '$HOST' '$PORT' '$USER' '$PASS' > /etc/proxychains4.conf"
              else
                # 匿名 SOCKS5
                sudo bash -c "printf 'strict_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n[ProxyList]\n%s %s %s\n' \
                  '$PROTO' '$HOST' '$PORT' > /etc/proxychains4.conf"
              fi
          
              AVAILABLE_PROXY="$proxy"
              break
            else
              PROXY_REPORT="${PROXY_REPORT}❌ $proxy (不可用)\n"
            fi
          done <<< "$SOCKS5_PROXY"
          
          # ==== 没有可用代理则退出 ====
          if [ -z "$AVAILABLE_PROXY" ]; then
            FAIL_MSG="❌ 没有可用的 SOCKS5 代理\n${PROXY_REPORT}任务终止 at $(date '+%Y-%m-%d %H:%M:%S')"
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d chat_id="${TELEGRAM_CHAT_ID}" \
              --data-urlencode text="$(echo -e "$FAIL_MSG")"
            exit 1
          else
            echo "本次使用代理: $AVAILABLE_PROXY"
            echo "$AVAILABLE_PROXY" > selected_proxy.txt
            echo -e "$PROXY_REPORT" > proxy_report.txt
            echo "==== proxychains4.conf ===="
            cat /etc/proxychains4.conf
          fi
      - name: Create accounts.json
        run: echo "$ACCOUNTS_JSON" > accounts.json

      - name: Generate and execute SSH commands (via proxy)
        run: |
          OUTPUT_FILE="ssh_output.txt"
          : > "$OUTPUT_FILE"
          while IFS= read -r account; do
            username=$(echo "$account" | jq -r '.username')
            password=$(echo "$account" | jq -r '.password')
            ssh_addr=$(echo "$account" | jq -r '.panel')
            echo "===== $username@$ssh_addr =====" | tee -a "$OUTPUT_FILE"
            proxychains4 sshpass -p "$password" ssh -o StrictHostKeyChecking=no "$username@$ssh_addr" "$CUSTOM_COMMAND" 2>&1 | tee -a "$OUTPUT_FILE"
            echo "" >> "$OUTPUT_FILE"
          done < <(jq -c '.[]' accounts.json)
      - name: Send Telegram notification with output
        if: always()
        run: |
          STATUS="✅ 执行完成"
          if [ "${{ job.status }}" != "success" ]; then
            STATUS="❌ 执行失败"
          fi
          PROXY_INFO="$(cat proxy_report.txt 2>/dev/null || echo '无代理信息')"
          MSG="$(cat ssh_output.txt)"
          MSG_TRUNC="${MSG:0:3500}"  # 避免超出 TG 限制
          FULL_MSG="$STATUS\n本次代理检测:\n$PROXY_INFO\n执行时间: $(date '+%Y-%m-%d %H:%M:%S')\n\`\`\`\n$MSG_TRUNC\n\`\`\`"
          # 关键：把 \n 变成真实换行再发送（Markdown 代码块保留）
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d chat_id="${TELEGRAM_CHAT_ID}" \
            -d parse_mode="Markdown" \
            --data-urlencode text="$(echo -e "$FULL_MSG")"
